#!/usr/bin/env racket
(module cfg-rkt racket/base
  (require racket/block)
  (require racket/file)
  (require racket/string)
  (require racket/system)

  ;; paths
  (define home-dir (string->path (getenv "HOME")))
  (define dotfiles-dir (if (getenv "DOTFILES")
                           (string->path (getenv "DOTFILES"))
                           (build-path home-dir "dotfiles")))

  (define categories-file
    (build-path dotfiles-dir "categories.txt"))
  (define linked-categories-file
    (build-path dotfiles-dir "categories.linked.txt"))
  (define (linked-files-file cat)
    (build-path dotfiles-dir (string-append cat ".linked.txt")))
  (define (linked-repos-file cat)
    (build-path dotfiles-dir (string-append cat ".linked-repos.txt")))

  ;; helpers
  (define (read-lines path)
    (if (file-exists? path)
        (with-input-from-file path
          (lambda ()
            (let loop [(res '())]
              (let [(line (read-line))]
                (if (eof-object? line)
                    res
                    (cons line (loop res)))))))
        '()))

  (define (append-lines-unique path lines)
    (define existing (read-lines path))
    (define new (filter (lambda (line) (not (member line existing))) lines))
    (with-output-to-file path
      (lambda () (for [(line new)] (displayln line)))
      #:exists 'append))

  (define (remove-lines path lines)
    (define existing (read-lines path))
    (delete-file path)
    (define new (filter (lambda (line) (not (member line lines))) existing))
    (with-output-to-file path
      (lambda () (for [(line new)] (displayln line)))
      #:exists 'append))

  (define (path-tree->strings tree)
    (cond [(path? tree) (list (path->string tree))]
          [(pair? tree) (append (path-tree->strings (car tree))
                                (path-tree->strings (cdr tree)))]
          [else '()]))

  (define categories (read-lines categories-file))

  (define (confirm . args)
    (let retry []
      (for [(arg args)]
        (display arg))
      (displayln " (y/n)")
      (case (read)
        ['y #t]
        ['n #f]
        [else (retry)])))

  (define (link-file src dest)
    (if (link-exists? dest)
        dest
        (if (or (file-exists? dest) (directory-exists? dest))
            (when (confirm (path->string dest)
                           " already exists? Would you like to overwrite it?")
              (block
               (delete-directory/files dest)
               (make-file-or-directory-link src dest)
               dest))
            (block
             (make-file-or-directory-link src dest)
             dest))))

  (define (link-dir src dest [top-level #t])
    (unless (directory-exists? dest)
      (make-directory dest))

    (for/list [(child (directory-list src))]
      (unless (and top-level
                   (equal? child (string->path "repos.txt")))
        (define src-child (build-path src child))
        (define dest-child (build-path
                            dest
                            (if top-level
                                (string-append "." (path->string child))
                                child)))

        (if (and (not (link-exists? src-child))
                 (directory-exists? src-child))
            (link-dir src-child dest-child #f)
            (link-file src-child dest-child)))))

  (define (link-repos dir)
    (define repos-file (build-path dir "repos.txt"))
    (if (file-exists? repos-file)
        (for/list [(line (read-lines repos-file))]
          (define parts (string-split line))
          (define url (car parts))
          (define path (build-path home-dir (cadr parts)))
          (unless (directory-exists? path)
            (system* "/usr/bin/env" "git" "clone" "--depth=1" url (path->string path)))
          path)
        '()))

  (define (git-pull repo)
    (current-directory repo)
    (system* "/usr/bin/env" "git" "pull"))

  ;; subcommands
  (define (help . _)
    (display "
cfg-rkt - dotfiles linking script re-written in racket

Available commands:
    help    Show this help text
    link    Create symlinks and clone repos
    unlink  Delete symlinks and delete repos
    update  Update the dotfiles repo and relink

This script should be able to work in parallel with the old one, for now, but in the future the config and state files will be written/generated in lisp.
"))

  (define (link to-link)
    ;; if nothing is specified then relink
    (when (and (null? to-link) (file-exists? linked-categories-file))
      (set! to-link (read-lines linked-categories-file)))

    ;; if still nothing then link default
    (when (null? to-link)
      (set! to-link (list "shell"
                          (case (system-type 'os*)
                            ['macosx "macos"]
                            ['linux "linux"]))))

    ;; if all specified, link all categories
    (when (equal? to-link '("all"))
      (set! to-link categories))

    ;; check that the specified categories exist
    (for [(cat to-link)]
      (unless (member cat categories)
        (display "unknown category: ")
        (displayln cat)
        (exit 1)))

    (for [(cat to-link)]
      (define linked (link-dir (build-path dotfiles-dir cat) home-dir))
      (append-lines-unique (linked-files-file cat)
                           (path-tree->strings linked))

      (define linked-repos (link-repos (build-path dotfiles-dir cat)))
      (append-lines-unique (linked-repos-file cat)
                           linked-repos))
    (append-lines-unique linked-categories-file to-link))

  (define (unlink to-unlink)
    ;; if nothing specified then don't unlink anything as this is destructive
    (when (null? to-unlink)
      (displayln "no category specified for unlinking")
      (displayln "to unlink all categories, use `cfg unlink all`")
      (exit 1))

    ;; if all specified, unlink all linked categories
    (when (equal? to-unlink '("all"))
      (set! to-unlink (read-lines linked-categories-file)))

    ;; check that the specified categories exist
    (for [(cat to-unlink)]
      (unless (member cat categories)
        (display "unknown category: ")
        (displayln cat)
        (exit 1)))

    ;; unlink
    (for [(cat to-unlink)]
      ;; files
      (let [(linked-file (linked-files-file cat))]
        (for [(file (read-lines linked-file))]
          (when (link-exists? file) (delete-file file)))
        (delete-file linked-file))

      ;; repos
      (let [(linked-file (linked-repos-file cat))]
        (for [(repo (read-lines linked-file))]
          (when (directory-exists? repo) (delete-directory/files repo)))
        (delete-file linked-file)))
    (remove-lines linked-categories-file to-unlink))

  (define (update args)
    (displayln "-- upating dotfiles repo")
    (git-pull home-dir)
    (displayln "-- re-linking")
    (link '())
    (for [(cat (read-lines linked-categories-file))]
      (display "-- updating repos for ")
      (displayln cat)
      (for [(repo (read-lines (linked-repos-file cat)))]
        (display "-- updating repo ")
        (displayln repo)
        (git-pull (string->path repo)))))

  (define commands (hash "help" help
                         "link" link
                         "unlink" unlink
                         "update" update))

  ;; run subcommand
  (let [(args (vector->list (current-command-line-arguments)))]
    (when (null? args)
      (displayln "no command specified")
      (help)
      (exit 1))
    ((hash-ref commands (car args)
               (lambda ()
                 (display "unknown command: ")
                 (displayln (car args))
                 (help)
                 (exit 1)))
     (cdr args))))

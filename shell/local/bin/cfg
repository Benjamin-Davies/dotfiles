#!/usr/bin/env bash

# Crash on error
set -e

# Sort common input
os="$(uname)"
home="$HOME"
dotfiles="${DOTFILES:-$HOME/dotfiles}"

command=$1
if [ -z $command ]; then
    echo No command given
    echo Use \`cfg help\` to get a list of available commands
    exit 1
fi
shift 1

# Helper functions
append_lines_unique() {
    local file="$1"
    shift 1

    printf "%s\n" "$@" >> "$file"
    sort -u -o "$file" "$file"
}

confirm() {
    local message="$1"

    echo "$message [y/n]"
    read res
    [ "$res" = y ]
}

link_file() {
    local src="$1"
    local dest="$2"

    if [ -e "$dest" ] || [ -L "$dest" ]; then
        if [ -L "$dest" ] && [ "$(readlink "$dest")" = "$src" ]; then
            return
        fi

        if ! confirm "$dest already exists! Would you like to overwrite it?"; then
            return
        fi

        rm -rf "$dest"
    fi

    ln -s "$src" "$dest"
}

link_directory() {
    local src="$1"
    local dest="$2"
    local top_level=${3:-true}

    mkdir -p "$dest"

    for child in $(ls "$src"); do
        local entry="$src/$child"

        if [ $top_level = true ]; then
            if [ "$child" = repos.txt ]; then
                continue
            fi

            # Modified after $entry is set so that entry contains path without dot
            # I don't know if local is required, but just to be safe as this is recursive
            local child=".$child"
        fi

        if [ ! -L "$entry" ] && [ -d "$entry" ]; then
            link_directory "$entry" "$dest/$child" false
        else
            link_file "$entry" "$dest/$child"
        fi

        linked+=("$dest/$child")
    done
}

link_repos() {
    local src=$1

    if [ ! -f "$src/repos.txt" ]; then
        return
    fi

    while read repo; do
        local url="$(cut -f 1 <<< "$repo")"
        local path="$home/$(cut -f 2 <<< "$repo")"

        if [ ! -e $path ]; then
            echo -- Cloning $url
            git clone --depth=1 "$url" "$path"
        fi

        if [ -d "$path/.git" ]; then
            linked_repos+=("$path")
        fi
    done < "$src/repos.txt"
}

# Subcommand functions
link() {
    # Link categories specified in args
    local to_link=($@)

    # If nothing is specified then relink
    if [ ${#to_link[@]} -eq 0 ] && [ -f "$dotfiles/categories.linked.txt" ]; then
        while read cat; do
            to_link+=($cat)
        done < "$dotfiles/categories.linked.txt"
    fi

    # If still nothing then link default (depends on platform)
    if [ ${#to_link[@]} -eq 0 ]; then
        to_link=(shell)
        case $os in
            Darwin)
                to_link+=(macos)
                ;;
            Linux)
                to_link+=(linux)
                ;;
        esac
    fi

    # If all specified, link all categories
    if [ "${to_link[*]}" = all ]; then
        to_link=()
        while read cat; do
            to_link+=($cat)
        done < "$dotfiles/categories.txt"
    fi

    # Check that the specified categories exist
    for cat in "${to_link[@]}"; do
        if [ -z $(grep $cat "$dotfiles/categories.txt") ]; then
            echo Category $cat does not exist
            exit 1
        fi
    done

    # Link
    for cat in "${to_link[@]}"; do
        linked=()
        link_directory "$dotfiles/$cat" "$home"
        append_lines_unique "$dotfiles/$cat.linked.txt" "${linked[@]}"

        linked_repos=()
        link_repos "$dotfiles/$cat"
        append_lines_unique "$dotfiles/$cat.linked-repos.txt" "${linked_repos[@]}"
    done
}

unlink() {
    local to_unlink=($@)

    # If nothing specified then don't unlink anything as this is destructive
    if [ ${#to_unlink[@]} -eq 0 ]; then
        echo No category specified for unlinking
        echo To unlink all categories, use `cfg unlink all`
        exit 1
    fi

    # If all specified, unlink all linked categories
    if [ "${to_unlink[*]}" = all ]; then
        while read cat; do
            to_unlink+=($cat)
        done < "$dotfiles/categories.linked.txt"
    fi

    # Check that the specified categories exist
    for cat in "${to_unlink[@]}"; do
        if [ -z $(grep $cat "$dotfiles/categories.txt") ]; then
            echo Category $cat does not exist
            exit 1
        fi
    done

    # Unlink
    for cat in "${to_unlink[@]}"; do
        # Files
        while read file; do
            rm -f "$file"
        done < "$dotfiles/$cat.linked.txt"
        rm "$dotfiles/$cat.linked.txt"

        # Repos
        while read file; do
            rm -rf "$file"
        done < "$dotfiles/$cat.linked-repos.txt"
        rm "$dotfiles/$cat.linked-repos.txt"
    done
}

update() {
    echo -- Updating dotfiles repo
    cd "$dotfiles"
    git pull

    echo -- Re-linking
    link

    for repo in $(cat $(ls | grep '\.linked-repos\.txt$')); do
        echo -- Updating repo $repo
        cd "$repo"
        git pull
    done
}

help() {
    echo 'Available commands:
    help    Show this help text
    link    Create symlinks and clone repos
    unlink  Delete symlinks and delete repos
    update  Update the dotfiles repo and relink

This command is designed to replace the old installation mechanism,
and should not require any changes to config or state files.'
}

# Subcommands
case $command in
    link) link $@ ;;
    unlink) unlink $@ ;;
    update) update $@ ;;
    help) help ;;
    *)
        echo Command $command not recognized
        help
        ;;
esac
